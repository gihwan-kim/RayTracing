- (참고1)[https://mkblog.co.kr/2019/09/09/rt-in-one-weekend-series-11-positionable-camera/]
- (참고2)[https://raytracing.github.io/books/RayTracingInOneWeekend.html]

1. vec 클래스
> vecotr, color 정보를 저장

2. vector, color utility functions
> 벡터 연산
> color 출력

3. Ray class
- Ray tacre 는 ray class 와 ray 를 통한 color 계산 기능 필요
- Ray : 무한한직선

> 직선의 방정식
- P(t) = origin + t * direction
- t : 실수



1. 눈 에서부터 pixel 까지의 ray 계산
2. 어떤 objet 가 ray 와 만나는지 결정
3. 접점의 색 결정

# viewport
```
    window 내부에 설정한 작은 창

    3 차원 장면을 가상 카메라의 위치에 투사하기위해 사용되는 2차원 직사각형

    전체 이미지가 표시될 부분을 보여주기 위해 사용되는 화면의 영역

    값을 설정하지 않으면 프로그램의 window 전체가 하나의 viewport 로 사용됨
```

# Surface Normal
```
    표면에 수직(prependicular) 인 벡터


    Normal 을 만들기 위한 두가지 방법
        normal 이 단위 길이인 경우 => 버그 발생할 수도 있음
        hit point 와 구의 중심을 빼서 noraml 벡터의 방향을 구할 수 있다.
```

# Sphere
```
    판별식 이용
        양수    : 근 2개
        0       : 근 1개
        음수    : 접하지 않는다.


    구와 ray 가 만나는 지점의 normal(구의 표면에 수직인 벡터)
        밖에서 시작된 ray
        구 안에서 시작된 ray

        어떤 ray 냐에 따라 normal 의 방향이 달라진다.

        ray 와 normal 이 같은 방향 : 안에서 시작된 ray, 내적 양수
        ray 와 normal 이 다른 방향 : 밖에서 시작된 ray, 내적 음수

        내적 : |ray||normal|cos


        ray 와 만는 평면을 안쪽에서 만나는 평면을 사용할지 밖에서 만나는 평면을 사용할지 결정해야한다.

        ray 와 normal 의 내적을 통해 방향이 같은지 확인할 수 있다.
```


# Anti-aliasing (AA)
```
    직선이 들쭉날쭉하거나 계단 모양으로 나타나는 경우
    그래픽스 출력 기기가 직선을 표시하기에 충분한 해상도를 가지고 있지 않을 때

    현실의 카메라로 사진을 찍을 경우 계단현상이 발생하지 않는다 => 그래픽으로 구현할때 발생

    픽셀 하나당 여러 샘플 ray 들을 만들어 color 값의 평균을 구해 해결할 수 있다.
        계단이 발생하는 부분의 색깔을 평균을 구해 색간의 구분을 흐릿하게해서 계단 모양을 없애기
        ray : random() 함수로 임의의 ray 를 만들어주기
        픽셀 하나의 색을 구할때 ray 들의 색을 더해서 ray 수만큼 나눠주기
```


# diffuse (난반사)
```
    빛이 반사될 때 다수의 방향으로 반사되는 경우

    렘베르트 반사 (Lambertian reflectance)
        관찰자가 바라보는 각도와 관계없이 같은 겉보기 밝기를 갖는다.

        반짝이는 처리가된 물체는 광원의 위치에 따라 거울면과 같은 하이라이트를 가질 수 있다.
        표면 처리가 되지 않은 물체는 보는 각도에 따라 밝기가 다르게 보이지 않음

        표면법선(법선(normal) : 표면의 방위(orientation)) 과 입사광이 이루는 각의 코사인 값 => 난 반사광의 양

            코사인을 계산하는 대신 내적(dot) 을 사용해 대신하자 (계산 방식이 더 간단함, 곱하기, 더하기로 되어있어서)

            벡터 두개를 정규화하여 길이를 1 로 만들면 쉡게 구할 수 있음

            cos = a * v / (|a||v|)

            |a| = 1, |b| = 1

    diffuse 를 계산하기 위해 렘베르트 반사 사용
        광선과 물체가 만나는 지점 P 에서 ray 와 바깥 표면의 법선 벡터 +N 에서
        임의의 구가 있다고 가정하고 구 안에서 임으의 점을 골라 난반사 광선을 생성해준다.

        생선한 광선을 쏘아서 다른 물체와 충돌하는지 확인
```


# Gomma-correctopm (감마 보정, gamma encoding)

    https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear
```
    비선형 전달 함수를 사용해 빛의 강도 신호를 비 선형적으로 변형하는 것

    모니터 표면의 인점을 자극하여 밝게, 어둡게 만드는 것은 전자빔의 양(세기)에 따라 조우되는데 전자빔의 세기는 회색도에 정비례한다. => 회색도에 정비례하는 전자빔이 발생한다.

   **인점의 명도는 전자빔의 세기에 대해 비선형적인 반응을 보인다.**
    회색도에 정비례하는 전자빔이 발생해도 인점의 명도는 전자빔의 세기에 비선형으로 반응

    명도에 대한 사용자의 인식
        전체적으로 어둡게 표현됨

    => 모니터의 이러한 문제를 해결하기위해 gamma correction 을 사용

    => 모니터 하드웨어마다 감마는 다르다. 보통 2.0 ~ 2.4 의

    빛의 세기가 선형적으로 증가하지만 사용자의 모니터환경에따라 명도가 다르게 보여 비선형적이게 될 수있음
```

1. 대부분의 유저들이 올바르지 않은 모니터를 사용하고 감마값이 2.2 으로 가정
2.
3. gamma correction 을 색을 마지막으로 출력하기전에 픽셀 값에 적용하기



# Shadow Acne
```
    수학적인 정밀도 오류때문에 난반사될때 원점이 물체의 표면보다 밑에 시작되는 오류가 발생할 수 있디.

    작은 점들이 생김
```


# Lambertian surface (완전 확산면, 렘버시안 표면, 랑베르 표면)
```
    어느 방향으로 보아도 휘도가 동일한
    반사광의 세기가 법선과 반사광의 사이 각
```

# Metarial
```
    물체마다 재질이 다른 특성을 적용

    빛이 닿는 물질이 매끄러운경우 반사(reflection - ) 이 발생
    표면이 매끄럽지 않으면 확산 반사(Diffuse Reflection)나 산란(Scattering)이 발생

    Scattering (산란)
        어떤 매질을 직선 경로로 통과하는 입자들이 (주로 빛이나 소리) “불균일한 입자”를 만나서 그들이 가던 경로를 벗어나는 현상
```

**--------------- 뭔 소리인지 모르겠음 ---------------**

1. Refraction (굴절)
```
    Snell's law(스넬의 법칙)
        굴절에 관한 물리법칙
        a sinA = b sinB
        a, b : 위, 아래 매질의 굴절계수
        A : 법선, 광원 벡터가 이루는 각
        B : 법선, 굴절 벡터가 이루는 각
```

2. Dielectric (유전체)
```
    투명한 표면
    반사, 굴절이 같이 발생
```
**------------------------------------------------**


# Positionable Camera : 시점 변경하기
```
    fov (화각) : 렌즈를 통해 이미지를 담을 수 있는 각
        보통 정사각형이 아니기 때문에 가로(horizontal), 세로(vertical) 값이 다름
        fps 게임의 경우 총구를 기준으로 n 도 정도의 이미지를 확인할 수 있는 것 처럼
        특정 순간에 화면에 출력되는 범위를 의미

        FOV 각도를 사용해서 화면에 표시되는 범위를 조절

    fov 값을 각도로 조정 했음


    (u, v, w)
        camera 의 위치, camera 가 바라보는 방향, 카메라를 설치하는 방향 (행성이 자전하는 것처럼) 을 임의로 설정해서 카메라를 이동할 수 있다.
        이값들을 사용해서 orthonormal basis (u, v, w) 를 만들어 화면을 생성할 수 있다.
            어디부터 어디까지 화면으로
```

# Defocus Blur (depth of field : DOF, 피사계 심도)
```
    한 사진의 초점이 맞은 것으로 인식되는 범위

    렌즈의 초점은 하나의 면에 정해지게 되어 있으나 실제 사진에서는 초점면을 중심으로 서서히 흐려지는 현상

    초점이 맞은 것으로 인식되는 범위의 한계 : 피사계 심도

    현실 카메라의 경우 카메라 렌즈의 구멍을 통해 빛을 모은다.


    1. 빛이 렌즈를 통과하거나 거울에 반사되면 빛이 모이거나 퍼진다.
    2. 초점 : 빛이 모여 상을 형성하는 지
    3. 초점 거리(focal distacne) : 렌즈, 거울의 광학기구와 초점간의 거리
```

1. focus distance vs focal length

```
focal length
    focusing palne (projection point)
```


```
    하나의 점에서 ray 가 시작되었다면 lookfrom 을 중심으로 만든 원(큰 렌즈)에서 ray 들이 발사되는
    것으로 구현할 수 있다.

    ray 의 시작점이 서로 달라진다. (lookfrom 를 중심으로한 원의 범위내에 있음)

    원이 커질 수록 dof 도 커진다.

    ray 의 시작 점이 ray 마다 달라졌기 떄문에 (카메라의 위치가 다 달라졌다.)
    camera 클래스에 정보를 담아두어야한다.

```